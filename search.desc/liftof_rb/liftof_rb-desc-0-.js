searchState.loadedDescShard("liftof_rb", 0, "Higher level functions, to deal with events/binary …\nConvenience functions to read/write the various control …\nOn-board memory management for readoutboards\nRegisters of the DRS4 are accessed through the sytem ram …\nDataport is 0MQ PUB for publishing waveform/event data\nstrip of the first 4 bytes of the incoming vector \nThe poisson self trigger mode of the board triggers …\nManage the RAM buffers for event data\nGet the active half of the RAM buffer\nGet the blob buffer size from occupancy register\nGet a runconfig from a file. \nCheck for the environmental  variable LIFTOF_IS_SYSTEMD …\nadd the board id to the bytestream in front of the  tof …\nAdd the prefix “LOCAL” to a bytestream.\nManage the RAM buffers for event data\nA full set of RB calibration\nReset DMA pointer and buffer occupancy registers\nCheck if the buffers are actually filling\nPrepare the whole readoutboard for data taking.\nWait as long as a run is active. This call blocks the …\nReset the DMA memory (blob data) and write 0s\ndo not write header only packets when the drs is busyu\nDisable the master trigger\nstop all triggers\nwrite header only packets when the drs is busy\nenable triggering\nGet the blob buffer occupancy for one of the two buffers\n! Get the board ID from the control registers.\n! Get the board ID from the control registers.\n! The device DNA is a unique identifier\nFIXME\nGet the event counter from the DRS4\nGet the event counter as sent from the MTB\nGet the rate as sent from the MTB\nGet the lost events event counter from the DRS4\nGet the rate of the lost triggers by the DRS4\nRead the link ID from the MTB \nGet the recorded triggers by the DRS4\nCheck if teh TRIGGER_ENABLE register is set\nPut the daq in idle state, that is stop data taking\n! Resets the DMA state machine.\nReset of the internal event counter\nReset means, the memory can be used again, but it does not …\nEnable active channels by not touching the ch9 bits\nThis simply sets the configure bit.\nEnable the master trigger mode\nEnable the readout of all channels + the 9th channel\nuse the random self trigger\nReset the board and prepare for a new run\nCheck if the soft reset procedure has finished\nStart DRS4 data acquistion\n! Toggle between the data buffers A and B\nForce a trigger\nData buffer related constants The data buffer is /dev/uio1 \n! There are 2 data buffers, commonly  denoted as “A” …\nThe size of a 32bit unsigned int in byte (all words in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllow READ access to the memory registers at /dev/uio**\nAllow WRITE access to the memory registers at /dev/uio0\nRead a data buffer directly into a RBEventMemory streamer, …\n! Get a single value from a 32bit (1 word) register This …\nRead one of the data buffers and return a bytestream  from …\nGet a size which accomodates nevents\nDRS counters\nDevice DNA (identifier) it is split in 2 32-bit words, …\nDRS trigger\nRAM management - there are two regions in memory, mapped …\nCentrailized command management\nManage the 0MQ PUB socket and send everything  which comes …\nTransforms raw bytestream to TofPackets\nGet LTB monitoring data for an RB board_id\nGet PB monitoring data for an RB board_id\nGet Preamp monitoring data for an RB board_id\nGet RB monitoring data for a RB board_id\nGather monitoring data and pass it on over a channel\nThread which controls run start/stop, deals with  …")