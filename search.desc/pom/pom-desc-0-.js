searchState.loadedDescShard("pom", 0, "Contains the error value\nParser error.\nContains the success value\nParser type, <code>Parser&lt;I, O&gt;</code> is alias of …\nParser result, <code>Result&lt;O&gt;</code> ia alias of <code>Result&lt;O, pom::Error&gt;</code>.\nUtility functions to recognize char class of byte value.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains predefined parsers and combinators.\nVariants of parser functions specialized for matching …\nRecognises an alphabetic character, <code>a-zA-Z</code>.\nRecognises an alphabetic character, <code>a-z</code>.\nRecognises an alphabetic character, <code>A-Z</code>.\nRecognises an alphanumeric character, <code>a-zA-Z0-9</code>.\nRecognises a decimal digit, <code>0-9</code>.\nRecognises a hexadecimal digit, <code>0-9a-fA-F</code>.\nRecognises a space, tab, line feed, or carriage return.\nRecognises an octal digit, <code>0-7</code>.\nRecognises a space or tab.\nParser combinator.\nMatch any symbol.\nCache parser output result to speed up backtracking.\nCall a parser factory, can be used to create recursive …\nCollect all matched input symbols.\nConvert parser result to desired value, fail in case of …\nDiscard parser output.\nAlways succeeds, consume no input.\nSuccess when end of input is reached.\nMark parser as expected, abort early when failed in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSuccess when predicate returns true on current input …\nParse separated list.\nConvert parser result to desired value.\nGive parser a name to identify parsing errors.\nCreate new parser.\nSuccess when current input symbol is none of the set.\nSuccess when predicate returns false on current input …\nSuccess when current input symbol is one of the set.\nMake parser optional.\nApply the parser to parse input.\nParse input at specified position.\nGet input position after matching parser.\n<code>p.repeat(5)</code> repeat p exactly 5 times <code>p.repeat(0..)</code> repeat …\nSuccess when sequence of symbols matches current input.\nSkip n symbols.\nSuccess when current input symbol equals <code>t</code>.\nSuccess when tag matches current input.\nRead n symbols.\nBeing wrapped in this struct guarantees that the parser …\nMatch any UTF-8 character.\nCache parser output result to speed up backtracking.\nCall a parser factory, can be used to create recursive …\nCollect all matched input symbols.\nConvert parser result to desired value, fail in case of …\nDiscard parser output.\nAlways succeeds, consume no input.\nSuccess when end of input is reached.\nMark parser as expected, abort early when failed in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSuccess when predicate returns true on current input …\nParse separated list.\nConvert parser result to desired value.\nGive parser a name to identify parsing errors.\nCreate new parser.\nSuccess when current input symbol is none of the set.\nSuccess when predicate returns false on current input …\nSuccess when current input symbol is one of the set.\nMake parser optional.\nApply the parser to parse input.\nParse input at specified byte position.\nApply the parser to parse input.\nGet input position after matching parser.\n<code>p.repeat(5)</code> repeat p exactly 5 times <code>p.repeat(0..)</code> repeat …\nSuccess when sequence of chars matches current input.\nSkip n symbols.\nSkip n bytes exactly.\nMatch specific UTF-8 character.\nRead n chars.\nRead n bytes exactly.")