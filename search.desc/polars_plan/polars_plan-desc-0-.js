searchState.loadedDescShard("polars_plan", 0, "Domain specific language for the Lazy API.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUtility struct for the <code>when-then-otherwise</code> expression.\nUtility struct for the <code>when-then-otherwise</code> expression.\nCan be used in a select statement to exclude a column from …\nExplode the aggregated list and just do a hstack instead …\nExpressions that can be used in various contexts. Queries …\nSpecialized expressions for modifying the name of existing …\nMap the group values to the position\nJoin the groups as ‘List&lt;group_dtype&gt;’ to the row …\nSet root name as Alias\nSpecialized expressions for <code>Series</code> of <code>DataType::List</code>.\nTake the nth column in the <code>DataFrame</code>\nExplode the aggregated list and just do a hstack instead …\nExpressions in this node should only be expanding e.g. …\nA wrapper trait for any binary closure …\nA wrapper trait for any closure …\nWrapper type that has special equality properties …\nA ternary operation if true then “foo” else “bar”\nUtility struct for the <code>when-then-otherwise</code> expression.\nUtility struct for the <code>when-then-otherwise</code> expression.\nSee postgres window functions\nGet the group indexes of the group by operation.\nRename Column.\nReturns whether all values in the column are <code>true</code>.\n“and” operation.\nReturns whether any of the values in the column are <code>true</code>.\nAppend expressions. This is done by adding the chunks of …\nApply a function/closure over the groups. This should only …\nApply a function/closure over the groups with many …\nApply a function/closure over the groups of multiple …\nReturn the index of the maximum value of every sublist\nGet the index value that has the maximum value.\nReturn the index of the minimal value of every sublist\nGet the index value that has the minimum value.\nGet the index values that would sort this expression.\nGet the first index of unique values of this expression.\nFill missing value with next non-null.\nGet the <code>binary::BinaryNameSpace</code>\nCompute <code>op(l, r)</code> (or equivalently <code>l op r</code>). <code>l</code> and <code>r</code> must …\nuse a cache of unique, converted dates to apply the …\nCast expression to another data type.\nCompute the cube root of the given expression\nCount the values of the Series or Get counts of the group …\nCompute the dot/inner product between two expressions.\nDrop NaN values.\nDrop null values.\nGet the <code>dt::DateLikeNameSpace</code>\nCompare <code>Expr</code> with other <code>Expr</code> on equality.\nCompare <code>Expr</code> with other <code>Expr</code> on equality where <code>None == None</code>…\nIf polars may parse matches that not contain the whole …\nExclude a column from a wildcard/regex selection.\nExplode the String/List column.\nReplace the floating point <code>NaN</code> values by a value.\nReplace the null values by a value.\nFilter a single column.\nFirst column in DataFrame.\nGet first item of every sublist.\nGet the first value in the group.\nAlias for <code>explode</code>.\nFloor divide <code>self</code> by <code>rhs</code>.\nFormatting string\nFill missing value with previous non-null.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA function that cannot be expressed with <code>map</code> or <code>apply</code> and …\nFunctions\nTake the values by idx.\nGet items in every sublist by index.\nTake the values by a single index.\nCheck if <code>Expr</code> &gt; <code>Expr</code>.\nCheck if <code>Expr</code> &gt;= <code>Expr</code>.\nGet the head of every sublist\nGet the first <code>n</code> elements of the Expr result.\nGroupBy the group to a Series.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet mask of finite values if dtype is Float.\nGet mask of infinite values if dtype is Float.\nGet mask of NaN values if dtype is Float.\nGet inverse mask of NaN values if dtype is Float.\nRun is_not_null operation on <code>Expr</code>.\nRun is_null operation on <code>Expr</code>.\nJoin all string items in a sublist and place a separator …\nKeep the original root name\nLast column in DataFrame.\nGet last item of every sublist.\nGet the last value in the group.\nReturn the number of rows in the context.\nReturn the number of elements in each list.\nGet the <code>list::ListNameSpace</code>\n“or” operation.\n“or” operation.\nGet minimal value that could be hold by this dtype.\nCheck if <code>Expr</code> &lt; <code>Expr</code>.\nCheck if <code>Expr</code> &lt;= <code>Expr</code>.\nDefine an alias by mapping a function over the original …\nApply a function/closure once the logical plan get …\nMap a single dtype.\nApply a function/closure once the logical plan get …\nApply a function/closure over multiple columns once the …\nApply a function/closure once the logical plan get …\nApply a function/closure over multiple columns once the …\nMap to a float supertype if numeric, else preserve\nMap to a float supertype.\nMap the dtype to the dtype of the list/array elements.\nMap the dtypes to the “supertype” of a list of lists.\nMap the dtype to the “supertype” of all fields.\nCompute the maximum of the items in every sublist.\nReduce groups to maximum value.\nCompute the mean of every sublist and return a <code>Series</code> of …\nReduce groups to the mean value.\nReduce groups to the median value.\nCompute the minimum of the items in every sublist.\nReduce groups to minimal value.\nGet the number of unique values in the groups.\nGet the <code>name::ExprNameNameSpace</code>\nReduce groups to maximum value.\nReduce groups to minimal value.\nCompare <code>Expr</code> with other <code>Expr</code> on non-equality.\nCompare <code>Expr</code> with other <code>Expr</code> on non-equality where …\nNegate <code>Expr</code>.\nGet the null count of the column/group.\n“or” operation.\nDefine a default for the <code>when-then-otherwise</code> expression.\nDefine a default for the <code>when-then-otherwise</code> expression.\nApply window function over a subgroup. This is similar to …\nRaise expression to the power <code>exponent</code>\nAdd a prefix to the root column name.\nGet the product aggregation of an expression.\nCompute the quantile per group.\nReverse every sublist\nReverse column\nProxy of the number of rows in both sides of the joins …\nSet this <code>Series</code> as <code>sorted</code> so that downstream code can use …\nShift every sublist.\nShift the values in the array by some period. See the …\nShift the values in the array by some period and fill the …\nShrink numeric columns to the minimal required datatype …\nSlice every sublist.\nSlice the Series. <code>offset</code> may be negative.\nSort every sublist.\nSort with given options.\nSort this column by the ordering of another column …\nCompute the square root of the given expression\nStandard deviation of the values of the Series.\nIf set then polars will return an error if any date …\nCast expression to another data type. Throws an error if …\nAdd a suffix to the root column name.\nCompute the sum the items in every sublist.\nReduce groups to the sum of all the values.\nGet the tail of every sublist\nGet the last <code>n</code> elements of the Expr result.\nAdd a condition to the <code>when-then-otherwise</code> expression.\nGet a dot language representation of the Expression.\nGet Field result of the expression. The schema is the …\nUpdate the root column name to use lowercase characters.\nMap to a physical type.\nUpdate the root column name to use uppercase characters.\nMap a single dtype with a potentially failing mapper …\nMap all dtypes with a potentially failing mapper function.\nMap a single field with a potentially failing mapper …\nKeep only the unique values in every sublist.\nGet unique values of this expression.\nKeep only the unique values in every sublist.\nGet unique values of this expression, while maintaining …\nGet maximal value that could be hold by this dtype.\nVariance of the values of the Series.\nStart a <code>when-then-otherwise</code> expression.\nAttach a statement to the corresponding condition.\nAdd another condition to the <code>when-then-otherwise</code> …\nSet a dtype.\nField with the same dtype.\n“xor” operation.\nfunction to apply\nAlso has the input. i.e. avg(“foo”)\nfunction to apply\nfunction arguments\nfunction arguments\nlength is not yet known so we accept negative offsets\noutput dtype of the function\nSpecialized expressions for <code>Series</code> of <code>DataType::String</code>.\nCheck if a binary value contains a literal binary.\nCheck if a binary value ends with the given sequence.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if a binary value starts with the given sequence.\nSpecialized expressions for <code>Series</code> with dates/datetimes.\nChange the underlying <code>TimeUnit</code>. And update the data …\nGet the century of a Date/Datetime\nCombine an existing Date/Datetime with a Time, creating a …\nGet the (local) date of a Date/Datetime.\nGet the (local) datetime of a Datetime.\nGet the month of a Date/Datetime.\nReturns the argument unchanged.\nGet the hour of a Datetime/Time64.\nCalls <code>U::from(self)</code>.\nGet the iso-year of a Date/Datetime. This may not …\nGet the microsecond of a Time64 (scaled from nanosecs).\nGet the millennium of a Date/Datetime\nGet the millisecond of a Time64 (scaled from nanosecs).\nGet the minute of a Datetime/Time64.\nGet the month of a Date/Datetime.\nGet the nanosecond part of a Time64.\nGet the ordinal_day of a Date/Datetime.\nExtract quarter from underlying NaiveDateTime …\nRound the Datetime/Date range into buckets.\nGet the second of a Datetime/Time64.\nConvert from Date/Time/Datetime into String with the given …\nGet the (local) time of a Date/Datetime/Time.\nReturn the timestamp (UNIX epoch) of a Datetime/Date.\nConvert from Date/Time/Datetime into String with the given …\nExpress a Duration in terms of its total number of integer …\nExpress a Duration in terms of its total number of integer …\nExpress a Duration in terms of its total number of …\nExpress a Duration in terms of its total number of …\nExpress a Duration in terms of its total number of integer …\nExpress a Duration in terms of its total number of …\nExpress a Duration in terms of its total number of integer …\nTruncate the Datetime/Date range into buckets.\nExtract the week from the underlying Date representation. …\nExtract the ISO week day from the underlying Date …\nChange the underlying <code>TimeUnit</code> of the <code>Series</code>. This does …\nGet the year of a Date/Datetime\nArguments used by <code>datetime</code> in order to produce an <code>Expr</code> of …\nArguments used by <code>duration</code> in order to produce an <code>Expr</code> of …\nSelects all columns. Shorthand for <code>col(&quot;*&quot;)</code>.\nCreate a new column with the bitwise-and of the elements …\nCreate a new column with the bitwise-or of the elements in …\nLike <code>map_binary</code>, but used in a group_by-aggregation …\nFind the mean of all the values in the column named <code>name</code>. …\nCasts the column given by <code>Expr</code> to a different type.\nFolds the expressions from left to right keeping the first …\nCreate a Column Expression based on a column name.\nSelect multiple columns by name.\nConcat lists entries.\nConstruct a column of <code>Datetime</code> from the provided …\nSelect multiple columns by dtype.\nSelect multiple columns by dtype.\nConstruct a column of <code>Duration</code> from the provided …\nAccumulate over multiple columns horizontally / row wise.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA column which is <code>false</code> wherever <code>expr</code> is null, <code>true</code> …\nA column which is <code>true</code> wherever <code>expr</code> is null, <code>false</code> …\nApply a closure on the two columns that are evaluated from …\nFind the maximum of all the values in the column named <code>name</code>…\nCreate a new column with the maximum value per row.\nFind the mean of all the values in the column named <code>name</code>. …\nCompute the mean of all values horizontally across columns.\nFind the median of all the values in the column named <code>name</code>…\nFind the minimum of all the values in the column named <code>name</code>…\nCreate a new column with the minimum value per row.\nConstruct a new <code>DatetimeArgs</code> set to <code>year</code>, <code>month</code>, <code>day</code>\nCreate a new <code>DurationArgs</code> with all fields set to <code>lit(0)</code>. …\nNegates a boolean column.\nFind a specific quantile of all the values in the column …\nAnalogous to <code>Iterator::reduce</code>.\nCreate a column of length <code>n</code> containing <code>n</code> copies of the …\nSum all the values in the column named <code>name</code>. Shorthand for …\nSum all values horizontally across columns.\nSet the day\nSet the days\nSet <code>milliseconds</code>, <code>microseconds</code>, and <code>nanoseconds</code>\nSet <code>hour</code>, <code>minute</code>, and <code>second</code>\nSet <code>hours</code>, <code>minutes</code>, and <code>seconds</code>\nSet the hour\nSet the hours\nSet the microsecond\nSet the microseconds\nSet the milliseconds\nSet the minute\nSet the minutes\nSet the month\nSet the nanoseconds\nSet the second\nSet the seconds\nSet the weeks\nSet the year\nRepresents a user-defined function\ncreates a logical expression with a call of the UDF This …\ncreates a logical expression with a call of the UDF This …\nReturns the argument unchanged.\nThe function implementation.\nThe function signature.\nCalls <code>U::from(self)</code>.\nname\nCreate a new UserDefinedFunction\nOptions for the function.\nThe function output type.\nAllowedOptimizations\nState of the allowed optimizations\nRun every node eagerly. This turns off multi-node …\nRun every node eagerly. This turns off multi-node …\nReplace simple projections with a faster inlined …\nReplace simple projections with a faster inlined …\nCache file reads.\nCache file reads.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nApply predicates/filters as early as possible.\nApply predicates/filters as early as possible.\nOnly read columns that are used later in the query.\nOnly read columns that are used later in the query.\nTry to estimate the number of rows so that joins can …\nTry to estimate the number of rows so that joins can …\nRun many expression optimization rules until fixed point.\nRun many expression optimization rules until fixed point.\nPushdown slices/limits.\nPushdown slices/limits.\nRun nodes that are capably of doing so on the streaming …\nRun nodes that are capably of doing so on the streaming …\nRun many type coercion optimization rules until fixed …\nRun many type coercion optimization rules until fixed …\nAny operation that is done on groups\nA raw binary array\nA binary true or false.\nCache the input at this point in the LP\nIn memory DataFrame\nAny operation that is done while projection/ selection of …\nRemove duplicates from the table\nCatches errors and throws them later\nThis allows expressions to access other tables\nFilter on a boolean mask\nA 32-bit floating point number.\nA 64-bit floating point number.\nGroupby aggregation\nHorizontal concatenation of multiple plans\nAdding columns to the table without a Join\n<code>IR</code> is a representation of <code>LogicalPlan</code> with <code>Node</code>s which are …\nA 16-bit integer number.\nA 32-bit integer number.\nA 64-bit integer number.\nAn 8-bit integer number.\nJoin operation\nA (User Defined) Function\nThe literal Null\nPolars’ <code>select</code> operation, this can mean projection, but …\nSlice the table\nSort the table\nOptimizer that uses a stack and memory arenas in favor of …\nA UTF8 encoded string type.\nAn unsigned 32-bit integer number.\nAn unsigned 64-bit integer number.\nspecify if the scan provider should allow predicate …\nspecify if the scan provider should allow predicate …\nspecify if the scan provider should allow projection …\nspecify if the scan provider should allow projection …\nspecify if the scan provider should allow slice pushdowns\nspecify if the scan provider should allow slice pushdowns\nCopy the exprs in this LP node to an existing container.\nPush inputs of the LP in of this node to an existing …\nArguments\nWhether this function will increase the number of rows\nApply a filter\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGetter for the <code>DataType</code> of the value\nGet expressions in this node.\nThis should be a 1 on 1 copy of the get_type method of …\nSet the <code>HivePartitions</code> information for this <code>FileInfo</code> from …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this function can run on batches of data at a time.\nCreate a Literal Expression from <code>L</code>. A literal expression …\nLiteral expression.\nConstructs a new <code>FileInfo</code>.\nconverts a node from the AExpr arena to Expr\nconverts a node from the IR arena to a LogicalPlan\nOptimize (subplan) in LogicalPlan\nOptimize (subplan) in LogicalPlan\nStores the schema used for the reader, as the main schema …\nknown sizeestimated size\nCreates a DataFrame from the supplied function &amp; scan …\nfunction to supply the schema. Allows for an optional …\nfunction to supply the schema. Allows for an optional …\nGet the schema of the logical plan node.\nconverts expression to AExpr and adds it to the arena, …\nconverts LogicalPlan to IR it adds expressions &amp; lps to …\nGet Field result of the expression. The schema is the …\nUpdate the <code>HivePartitions</code> statistics for this <code>FileInfo</code>.\nDefines different visitor patterns and for any tree.\nTakes the expressions of an LP node and the inputs of that …\nfunction to apply\nFunction arguments Some functions rely on aliases, for …\nallow predicate pushdown optimizations\nallow projection pushdown optimizations\nHow many hits the cache must be saved in memory.\ngeneric options that can be used for all file types.\nschema of the projected file\nA Node that is restricted to <code>AExpr::Column</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContinue the visit to this node tree.\nContinue the visit to this node and children.\nCall <code>op</code> immediately and return This doesn’t visit the …\nDon’t mutate this node, continue visiting the children\nControls how the <code>TreeWalker</code> recursion should proceed for …\nKeep recursive but skip applying op on the children\nStop the visit to this node tree.\nStop and return. This doesn’t visit the children\nAn implementor of this trait decides how and in which …\nControls how the <code>TreeWalker</code> recursion should proceed for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the <code>Node</code>.\nInvoked after all children of <code>node</code> are visited. Default …\nInvoked after all children of <code>node</code> are visited. Default …\nInvoked before any children of <code>node</code> are visited.\nInvoked before any children of <code>node</code> are visited.\nInvoked before any children of <code>node</code> are visited.\nInvoked before any children of <code>node</code> are visited.\nReplace the current <code>Node</code> with a new <code>IR</code>.\nWalks all nodes in depth-first-order.\nWalks all nodes in depth-first-order.\nGeneric options for all file types.\nCollect groups to a list and apply the function over the …\nCollect groups to a list and apply the function over the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSafety\nThere can be two ways of expanding wildcards:\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAny function that is sensitive to the number of elements …\nWhich rows to keep.\nThis will maintain the order of the input. Note that this …\nallow predicate pushdown optimizations\nallow projection pushdown optimizations\nAutomatically explode on unit length if it ran as final …\nTake only a slice of the result\nTake only a slice of the result\nSubset of columns that will be taken into account.\nUtility to write comma delimited strings\noutput name of expr\nunpack alias(col) to name of the root column name\nThis should gradually replace expr_to_root_column as this …\nTake a list of expressions and a schema and determine the …\nConcatenate multiple schemas into one, disallowing …")