<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust has a problematic relationship with recursive functions, because functions that recurse deeply can overflow the stack, crashing your program. This crate makes it easy to remedy this problem by marking (indirectly) recursive functions as such:"><title>recursive - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-081576b923113409.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="recursive" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0 (129f3b996 2024-06-10)" data-channel="1.79.0" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-e32f0c247825364d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../recursive/index.html">recursive</a><span class="version">0.1.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#functions">Functions</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../recursive/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">recursive</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/recursive/lib.rs.html#1-90">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Rust has a problematic relationship with recursive functions, because functions that recurse
deeply can overflow the stack, crashing your program. This crate makes it easy to remedy
this problem by marking (indirectly) recursive functions as such:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>recursive::recursive;

<span class="attr">#[recursive]
</span><span class="kw">fn </span>sum(nums: <span class="kw-2">&amp;</span>[u64]) -&gt; u64 {
    <span class="kw">if let </span><span class="prelude-val">Some</span>((head, tail)) = nums.split_first() {
        head + sum(tail)
    } <span class="kw">else </span>{
        <span class="number">0
    </span>}
}</code></pre></div>
<p>The way this prevents stack overflows is by checking the size of the remaining stack at the
start of each call to your function. If this size is under a boundary set by
<a href="fn.set_minimum_stack_size.html" title="fn recursive::set_minimum_stack_size"><code>set_minimum_stack_size</code></a> (by default 128 KiB), a new stack is allocated and execution
continues on that stack. This new stack’s size is set using <a href="fn.set_stack_allocation_size.html" title="fn recursive::set_stack_allocation_size"><code>set_stack_allocation_size</code></a>, which
is 2 MiB by default.</p>
<p>This crate works by wrapping your function body in a call to <a href="../stacker/fn.maybe_grow.html" title="fn stacker::maybe_grow"><code>stacker::maybe_grow</code></a>. If this
crate is not flexible enough for your needs consider using <a href="../stacker/index.html" title="mod stacker"><code>stacker</code></a> directly yourself.</p>
<h3 id="what-are-the-downsides"><a class="doc-anchor" href="#what-are-the-downsides">§</a>What are the downsides?</h3>
<p>This crate is <strong>not</strong> zero cost, but it is also not limited to simple tail recursion or direct
recursion. However, in most cases the stack size test is very fast and almost always succeeds
without needing to allocate. If your recursive algorithm is very performance-sensitive I would
suggest rewriting it to an iterative version regardless.</p>
<p>This crate only supports those platforms that <a href="../stacker/index.html" title="mod stacker"><code>stacker</code></a> supports. The Rust compiler itself
uses <a href="../stacker/index.html" title="mod stacker"><code>stacker</code></a>, so the platform you’re compiling on should always be fine, but for more
obscure targets see its documentation.</p>
<h3 id="which-functions-should-i-mark-as-recursive"><a class="doc-anchor" href="#which-functions-should-i-mark-as-recursive">§</a>Which functions should I mark as <code>#[recursive]</code>?</h3>
<p>Any function that directly calls itself should be marked as <code>#[recursive]</code>, unless you know for
certain that the stack is sufficiently large for any inputs that function will be called with.
If you are feeding untrusted input into a recursive function you should always mark it as
<code>#[recursive]</code>.</p>
<p>It is not necessary to mark every single function that can indirectly recurse as <code>#[recursive]</code>.
As long as every possible cycle of function calls includes at least one function marked
<code>#[recursive]</code> you will be protected against stack overflows due to recursion.</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.get_minimum_stack_size.html" title="fn recursive::get_minimum_stack_size">get_minimum_stack_size</a></div><div class="desc docblock-short">Returns the value set by <a href="fn.set_minimum_stack_size.html" title="fn recursive::set_minimum_stack_size"><code>set_minimum_stack_size</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.get_stack_allocation_size.html" title="fn recursive::get_stack_allocation_size">get_stack_allocation_size</a></div><div class="desc docblock-short">Returns the value set by <a href="fn.set_stack_allocation_size.html" title="fn recursive::set_stack_allocation_size"><code>set_stack_allocation_size</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.set_minimum_stack_size.html" title="fn recursive::set_minimum_stack_size">set_minimum_stack_size</a></div><div class="desc docblock-short">This sets the minimum stack size that <a href="attr.recursive.html" title="attr recursive::recursive"><code>recursive</code></a> requires.</div></li><li><div class="item-name"><a class="fn" href="fn.set_stack_allocation_size.html" title="fn recursive::set_stack_allocation_size">set_stack_allocation_size</a></div><div class="desc docblock-short">When a new stack gets allocated it will get allocated with this size.</div></li></ul><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.recursive.html" title="attr recursive::recursive">recursive</a></div><div class="desc docblock-short">Marks a function to use an automatically growing segmented stack.</div></li></ul></section></div></main></body></html>