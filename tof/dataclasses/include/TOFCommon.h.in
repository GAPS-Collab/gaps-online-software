#ifndef TOFCOMMON
#define TOFCOMMON

#include <vector>

// This include file defines anything that is needed by multiple threads. 


#define MEM_EVENTS   @MEMEVENTS@
// Set to one larger than the actual number until we start using RB0
#define MAX_BRDS     @N_READOUT_BOARDS@        
#define NCHN         @NCHANNELS@
#define CHNTOT       MAX_BRDS * NCHN
// To calculate NPADDLE, remember that CH9 on each RB is not SiPM data
#define NPADDLE      (MAX_BRDS * (NCHN - 1))/2 
#define NWORDS       1024

// send an environmental package every 
// heartbeat seconds
static const uint8_t ENVHEARTBEATSECONDS = 30;

// over what time to average? (In seconds
static constexpr uint8_t ENVAVERAGEINTERVAL = ENVHEARTBEATSECONDS;

// FIXME - use the prooper ids as they are in the database
static const std::vector<uint8_t> READOUTBOARDIDS = std::vector<uint8_t> {1,2,3};

namespace GAPS {

  enum class PADDLE_END : std::uint16_t {
      A = 10,
      B = 20,
      UNKNOWN = 30
  }

}
enum TOFDATA_TYPE { TOFDATA_NONE,     TOFDATA_EVENT, TOFDATA_FULL,
		    TOFDATA_INTEREST, TOFDATA_ALL};

// ZMQ Init flags
enum ZMQ_INIT { ZMQ_ALL, ZMQ_THREADS }; 

// Socket Names for inter-thread communication
enum SOCKETS { RBCOMM, ANALYZE, SEND, N_SOCKETS}; 

// Status of memory event
enum EVT_STAGE { EVT_NONE, EVT_BLOBPart, EVT_BLOBFull,
		 EVT_REDUCED, EVT_SENT};

// These quantities relate to the ZMQ sockets
typedef struct SOCKET_INFO {
  void *data_socket;
  char svr_socket[200];
  int svr_port;
  int size;
} sockinf_t;

// These quantities relate to the current run conditions
// The only thread that should write to these quantities is RBCommunication
typedef struct RUN_DATA
{
  // How many RBs are sending data
  int nBrdsExpected;
  int BrdFound[MAX_BRDS];
  // Stuff needed to find/fill the UTC for each event
  bool firstBlob;
  unsigned long firstEvent;
  unsigned long long RefTimestamp[MAX_BRDS];
  unsigned long UTCEvtID;
  unsigned long UTCSecs;
  unsigned long UTCMSecs;
} RunData_t;

// These quantities relate to the current event
// The only thread that should write to these quantities is AnalyzeEvt
typedef struct REDUCED_DATA
{
  unsigned short n_pad; // Number of paddles with data
  unsigned short hitmask[NPADDLE];
  double PedA[NPADDLE], PedB[NPADDLE];
  double PedA_RMS[NPADDLE], PedB_RMS[NPADDLE];
  double QintA[NPADDLE], QintB[NPADDLE];
  double VPeakA[NPADDLE], VPeakB[NPADDLE];
  double TcthreshA[NPADDLE], TcthreshB[NPADDLE];
  double TcfdsA[NPADDLE], TcfdsB[NPADDLE];
} ReducedData_t;

// These quantities are read in from a blob
typedef struct BLOB_DATA
{
  unsigned short head; // Head of event marker
  unsigned short status;
  unsigned short len;
  unsigned short roi;
  unsigned long long dna;
  unsigned short fw_hash;
  unsigned short id;
  unsigned short ch_mask;
  unsigned long event_ctr;
  unsigned short dtap0;
  unsigned short dtap1;
  unsigned long long timestamp;
  unsigned short ch_head[NCHN];
  short ch_adc[NCHN][NWORDS];
  unsigned long ch_trail[NCHN];
  unsigned short stop_cell;
  unsigned long crc32;
  unsigned short tail; // End of event marker
} BlobEvt_t ;  

// These quantities are stored in memory for analysis
typedef struct EVENT_DATA
{
  // THE ONLY THREAD THAT WRITES TO THIS QUANTITY IS DATAMANAGE
  int EvtStatus;                 // Where in processing is this event

  // THE ONLY THREAD THAT SHOULD WRITE TO THESE QUANTITIES IS RBCOMMUNICATION
  int nBrds;
  // Quantities directly (or quickly found) from blobs
  unsigned long EvtNumber;       // event_ctr from blobs
  bool HaveRefTime;              // Reference time found and available
  bool HaveEventTime;            // Event time found and filled
  unsigned long RefEvtCtr;       // Event_ctr for reference event
  unsigned long RefEvtSeconds;   // tof-gfp time(s) for reference event
  unsigned long RefEvtMicroSecs; // tof-gfp time(microsec) for reference event
  unsigned long long RefTimestamp[MAX_BRDS]; // timestamp for reference event
  unsigned long EventTimeSec;   // Time of this event
  unsigned long EventTimeMSec;  // Time of this event
  //short ADC[CHNTOT][NWORDS];       // ADC values from blob by actual channel
  unsigned long long timestamp[MAX_BRDS]; // Blob timestamp
  unsigned long long dna[MAX_BRDS];   // Blob dna
  unsigned short ch_mask[MAX_BRDS];   // Blob ch_mask
  unsigned short stop_cell[MAX_BRDS]; // Blob stop_cell
  //unsigned short roi[NBRDS];       // Blob roi
  double ADC[CHNTOT][NWORDS];         // Calibrated ADC values by actual ch
  double Time[CHNTOT][NWORDS];        // Calibrated Time values by actual ch

  // THE ONLY THREAD THAT SHOULD WRITE TO THESE QUANTITIES IS ANALYZEEVT
  // Quantities found from analyzing event data. 
  ReducedData_t Data;
} MemEvt_t;

// Everything from here to the end of the file is archival code from
// pGAPS. It is useful for developing some data management routines
// but can be deleted eventually. JAZ 3 June 2022

typedef struct EVENT1_DATA {
  unsigned int   EventNum;

  unsigned int   EventTimeSec;   // Time of this event
  unsigned short EventTimeMSec;  // Time of this event

  unsigned long  ClockCounter;
  unsigned long  ClockSync;

  unsigned int tdc[CHNTOT];
  unsigned int adc[CHNTOT];
  unsigned int scaler[CHNTOT];

  unsigned short n_tdc;
  unsigned short n_adc;

  unsigned short tdc_overflow[CHNTOT];
  unsigned short adc_overflow[CHNTOT];
  
  unsigned int tdc_event_ctr;
  unsigned int adc_event_ctr;
} event_t;

typedef struct BRUN_DATA {
  unsigned int   RunNum;
  unsigned int   RunStartTime;
  unsigned int   FileOpenTime;
} brun_t;

typedef struct ERUN_DATA {
  unsigned int   RunNum;
  unsigned int   FileCloseTime;
} erun_t;

#endif
