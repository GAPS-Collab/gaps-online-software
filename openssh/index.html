<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Scriptable SSH through OpenSSH (only works on unix)."><title>openssh - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="openssh" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.2 (25ef9e3d8 2024-04-09)" data-channel="1.77.2" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../openssh/index.html">openssh</a><span class="version">0.10.4</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../openssh/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">openssh</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/openssh/lib.rs.html#1-202">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Scriptable SSH through OpenSSH (<strong>only works on unix</strong>).</p>
<p>This crate wraps the OpenSSH remote login client (<code>ssh</code> on most machines), and provides
a convenient mechanism for running commands on remote hosts. Since all commands are executed
through the <code>ssh</code> command, all your existing configuration (e.g., in <code>.ssh/config</code>) should
continue to work as expected.</p>
<h2 id="executing-remote-processes"><a class="doc-anchor" href="#executing-remote-processes">§</a>Executing remote processes</h2>
<p>The library’s API is modeled closely after that of <a href="https://doc.rust-lang.org/1.77.2/std/process/struct.Command.html" title="struct std::process::Command"><code>std::process::Command</code></a>, since <code>ssh</code> also
attempts to make the remote process seem as much as possible like a local command. However,
there are some differences.</p>
<p>First of all, all remote commands are executed in the context of a single ssh
<a href="struct.Session.html" title="struct openssh::Session">session</a>. Authentication happens once when the session is
<a href="struct.Session.html#method.connect" title="associated function openssh::Session::connect">established</a>, and subsequent command invocations re-use the same connection.</p>
<p>Note that the maximum number of multiplexed remote commands is 10 by default. This value can be
increased by changing the <code>MaxSessions</code> setting in <a href="https://linux.die.net/man/5/sshd_config"><code>sshd_config</code></a>.</p>
<p>Much like with <a href="https://doc.rust-lang.org/1.77.2/std/process/struct.Command.html" title="struct std::process::Command"><code>std::process::Command</code></a>, you have multiple
options when it comes to launching a remote command. You can
<a href="struct.OwningCommand.html#method.spawn" title="method openssh::OwningCommand::spawn">spawn</a> the remote command, which just gives you a
handle to the running process, you can run the command and wait
for its <a href="struct.OwningCommand.html#method.output" title="method openssh::OwningCommand::output">output</a>, or you can run it and just
extract its <a href="struct.OwningCommand.html#method.status" title="method openssh::OwningCommand::status">exit status</a>. Unlike its <code>std</code>
counterpart though, these methods on <a href="struct.OwningCommand.html" title="struct openssh::OwningCommand"><code>OwningCommand</code></a> can fail
even if the remote command executed successfully, since there is a
fallible network separating you from it.</p>
<p>Also unlike its <code>std</code> counterpart, <a href="struct.OwningCommand.html#method.spawn" title="method openssh::OwningCommand::spawn"><code>spawn</code></a> gives you a <a href="struct.Child.html" title="struct openssh::Child"><code>Child</code></a> rather
than a <a href="https://doc.rust-lang.org/1.77.2/std/process/struct.Child.html" title="struct std::process::Child"><code>std::process::Child</code></a>. Behind the scenes, a remote child is really just a process
handle to the <em>local</em> <code>ssh</code> instance corresponding to the spawned remote command. The behavior
of the methods of <a href="type.RemoteChild.html" title="type openssh::RemoteChild"><code>RemoteChild</code></a> therefore match the behavior of <code>ssh</code>, rather than that of
the remote command directly. Usually, these are the same, though not always, as highlighted in
the documetantation the individual methods. See also the section below on Remote Shells.</p>
<h2 id="connection-modes"><a class="doc-anchor" href="#connection-modes">§</a>Connection modes</h2>
<p>This library provides two way to connect to the <a href="https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing"><code>ControlMaster</code></a>:</p>
<p>One is to spawn a new process, the other is to connect to
the control socket directly.</p>
<p>The process implementation executes remote commands by invoking
the ssh command locally with arguments that make the invocation
reuse the connections set up by the control master.</p>
<p>This maximizes compatibility with OpenSSH, but loses out on some fidelity
in information about execution since only the exit code and the output of
the ssh command is available to inspect.</p>
<p>The native mux implementation on the other hand connects directly to
the ssh control master and executes commands and retrieves the exit codes and
the output of the remote process over its native protocol.</p>
<p>This gives better access to error information at the cost of introducing
more non-OpenSSH code into the call path.</p>
<p>The former parses the stdout/stderr of the ssh control master to retrieve the error
for any failed operations, while the later retrieves the error from the control socket
directly.</p>
<p>Thus, the error handling in the later is more robust.</p>
<p>Also, the former requires one process to be spawn for every connection while the later only
needs to create one socket, so the later has better performance and consumes less resource.</p>
<p>Behind the scenes, the crate uses ssh’s <a href="https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing"><code>ControlMaster</code></a> feature to multiplex the channels for
the different remote commands. Because of this, each remote command is tied to the lifetime of
the <a href="struct.Session.html" title="struct openssh::Session"><code>Session</code></a> that spawned them. When the session is <a href="struct.Session.html#method.close" title="method openssh::Session::close">closed</a>, the connection
is severed, and there can be no outstanding remote clients.</p>
<h2 id="authentication"><a class="doc-anchor" href="#authentication">§</a>Authentication</h2>
<p>This library supports only password-less authentication schemes. If running <code>ssh</code> to a target
host requires you to provide input on standard input (<code>STDIN</code>), then this crate will not work
for you. You should set up keypair-based authentication instead.</p>
<h2 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h2>
<p>Since we are wrapping the <code>ssh</code>, which in turn runs a remote command that we do not control, we
do not have a reliable way to tell the difference between what is a failure of the SSH
connection itself, and what is a program error from the remote host. We do our best with some
heuristics (like <code>ssh</code> exiting with status code 255 if a connection error occurs), but the
errors from this crate will almost necessarily be worse than those of a native SSH
implementation. Sorry in advance :)</p>
<p>This also means that you may see strange errors when the remote process is terminated by a
signal (such as through <code>kill</code> or <code>pkill</code>). When this happens, all the local ssh program sees
is that the remote process disappeared, and so it returns with an error. It does not
communicate that the process exited due to a signal. In cases like this, your call will return
<a href="enum.Error.html#variant.Disconnected" title="variant openssh::Error::Disconnected"><code>Error::Disconnected</code></a>, because the connection to <em>that</em> remote process was disconnected. The
ssh connection as a whole is likely still intact.</p>
<p>To check if the connection has truly failed, use <a href="struct.Session.html#method.check" title="method openssh::Session::check"><code>Session::check</code></a>. It will return <code>Ok</code> if the
master connection is still operational, and <em>may</em> provide you with more information than you
got from the failing command (that is, just <a href="enum.Error.html#variant.Disconnected" title="variant openssh::Error::Disconnected"><code>Error::Disconnected</code></a>) if it is not.</p>
<h2 id="remote-shells"><a class="doc-anchor" href="#remote-shells">§</a>Remote Shells</h2>
<p>When you invoke a remote command through ssh, the remote command is executed by a shell on the
remote end. That shell <em>interprets</em> anything passed to it — it might evalute words starting
with <code>$</code> as variables, split arguments by whitespace, and other things a shell is wont to do.
Since that is <em>usually</em> not what you expect to happen, <code>.arg(&quot;a b&quot;)</code> should pass a <em>single</em>
argument with the value <code>a b</code>, <code>openssh</code> <em>escapes</em> every argument (and the command itself) by
default using <a href="https://crates.io/crates/shell-escape"><code>shell-escape</code></a>. This works well in most cases, but might run into issues when
the remote shell (generally the remote user’s login shell) has a different syntax than the
shell <code>shell-escape</code> targets (bash). For example, Windows shells have different escaping syntax
than bash does.</p>
<p>If this applies to you, you can use <a href="struct.OwningCommand.html#method.raw_arg" title="method openssh::OwningCommand::raw_arg"><code>raw_arg</code></a>,
<a href="struct.OwningCommand.html#method.raw_args" title="method openssh::OwningCommand::raw_args"><code>raw_args</code></a>, and <a href="struct.Session.html#method.raw_command" title="method openssh::Session::raw_command"><code>raw_command</code></a> to bypass the
escaping that <code>openssh</code> normally does for you.</p>
<h2 id="sftp-subsystem"><a class="doc-anchor" href="#sftp-subsystem">§</a>Sftp subsystem</h2>
<p>For sftp and other ssh subsystem, check <a href="struct.Session.html#method.subsystem" title="method openssh::Session::subsystem"><code>Session::subsystem</code></a> for more information.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>openssh::{Session, KnownHosts};

<span class="kw">let </span>session = Session::connect_mux(<span class="string">"me@ssh.example.com"</span>, KnownHosts::Strict).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let </span>ls = session.command(<span class="string">"ls"</span>).output().<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">eprintln!</span>(<span class="string">"{}"</span>, String::from_utf8(ls.stdout).expect(<span class="string">"server output was not valid UTF-8"</span>));

<span class="kw">let </span>whoami = session.command(<span class="string">"whoami"</span>).output().<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(whoami.stdout, <span class="string">b"me\n"</span>);

session.close().<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="changelog/index.html" title="mod openssh::changelog">changelog</a></div><div class="desc docblock-short">Changelog for this crate.</div></li><li><div class="item-name"><a class="mod" href="process/index.html" title="mod openssh::process">process</a></div><div class="desc docblock-short">Types to create and interact with the Remote Process</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Child.html" title="struct openssh::Child">Child</a></div><div class="desc docblock-short">Representation of a running or exited remote child process.</div></li><li><div class="item-name"><a class="struct" href="struct.ChildStderr.html" title="struct openssh::ChildStderr">ChildStderr</a></div><div class="desc docblock-short">Stderr for the remote child.</div></li><li><div class="item-name"><a class="struct" href="struct.ChildStdin.html" title="struct openssh::ChildStdin">ChildStdin</a></div><div class="desc docblock-short">Input for the remote child.</div></li><li><div class="item-name"><a class="struct" href="struct.ChildStdout.html" title="struct openssh::ChildStdout">ChildStdout</a></div><div class="desc docblock-short">Stdout for the remote child.</div></li><li><div class="item-name"><a class="struct" href="struct.OwningCommand.html" title="struct openssh::OwningCommand">OwningCommand</a></div><div class="desc docblock-short">A remote process builder, providing fine-grained control over how a new remote process should
be spawned.</div></li><li><div class="item-name"><a class="struct" href="struct.Session.html" title="struct openssh::Session">Session</a></div><div class="desc docblock-short">A single SSH session to a remote host.</div></li><li><div class="item-name"><a class="struct" href="struct.SessionBuilder.html" title="struct openssh::SessionBuilder">SessionBuilder</a></div><div class="desc docblock-short">Build a <a href="struct.Session.html" title="struct openssh::Session"><code>Session</code></a> with options.</div></li><li><div class="item-name"><a class="struct" href="struct.Stdio.html" title="struct openssh::Stdio">Stdio</a></div><div class="desc docblock-short">Describes what to do with a standard I/O stream for a remote child process
when passed to the stdin, stdout, and stderr methods of Command.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ControlPersist.html" title="enum openssh::ControlPersist">ControlPersist</a></div><div class="desc docblock-short">Specifies how long the controlling ssh process should stay alive.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum openssh::Error">Error</a></div><div class="desc docblock-short">Errors that occur when interacting with a remote process.</div></li><li><div class="item-name"><a class="enum" href="enum.ForwardType.html" title="enum openssh::ForwardType">ForwardType</a></div><div class="desc docblock-short">Type of forwarding</div></li><li><div class="item-name"><a class="enum" href="enum.KnownHosts.html" title="enum openssh::KnownHosts">KnownHosts</a></div><div class="desc docblock-short">Specifies how the host’s key fingerprint should be handled.</div></li><li><div class="item-name"><a class="enum" href="enum.Socket.html" title="enum openssh::Socket">Socket</a></div><div class="desc docblock-short">TCP/Unix socket</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.OverSsh.html" title="trait openssh::OverSsh">OverSsh</a></div><div class="desc docblock-short">If a command is <code>OverSsh</code> then it can be executed over an SSH session.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Command.html" title="type openssh::Command">Command</a></div><div class="desc docblock-short">Convenience <a href="struct.OwningCommand.html" title="struct openssh::OwningCommand"><code>OwningCommand</code></a> alias when working with a session reference.</div></li><li><div class="item-name"><a class="type" href="type.RemoteChild.html" title="type openssh::RemoteChild">RemoteChild</a></div><div class="desc docblock-short">Convenience <a href="struct.Child.html" title="struct openssh::Child"><code>Child</code></a> alias when working with a session reference.</div></li></ul></section></div></main></body></html>